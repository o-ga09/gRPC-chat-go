// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"gRPC-chat/api/domain"
	"sync"
)

// Ensure, that OutputPortMock does implement OutputPort.
// If this is not the case, regenerate this file with moq.
var _ OutputPort = &OutputPortMock{}

// OutputPortMock is a mock implementation of OutputPort.
//
//	func TestSomethingThatUsesOutputPort(t *testing.T) {
//
//		// make and configure a mocked OutputPort
//		mockedOutputPort := &OutputPortMock{
//			ReceiveMessageFunc: func(contextMoqParam context.Context) domain.Message {
//				panic("mock out the ReceiveMessage method")
//			},
//			SendMessageFunc: func(contextMoqParam context.Context, messageBody domain.MessageBody) domain.MessageStatus {
//				panic("mock out the SendMessage method")
//			},
//		}
//
//		// use mockedOutputPort in code that requires OutputPort
//		// and then make assertions.
//
//	}
type OutputPortMock struct {
	// ReceiveMessageFunc mocks the ReceiveMessage method.
	ReceiveMessageFunc func(contextMoqParam context.Context) domain.Message

	// SendMessageFunc mocks the SendMessage method.
	SendMessageFunc func(contextMoqParam context.Context, messageBody domain.MessageBody) domain.MessageStatus

	// calls tracks calls to the methods.
	calls struct {
		// ReceiveMessage holds details about calls to the ReceiveMessage method.
		ReceiveMessage []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SendMessage holds details about calls to the SendMessage method.
		SendMessage []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// MessageBody is the messageBody argument value.
			MessageBody domain.MessageBody
		}
	}
	lockReceiveMessage sync.RWMutex
	lockSendMessage    sync.RWMutex
}

// ReceiveMessage calls ReceiveMessageFunc.
func (mock *OutputPortMock) ReceiveMessage(contextMoqParam context.Context) domain.Message {
	if mock.ReceiveMessageFunc == nil {
		panic("OutputPortMock.ReceiveMessageFunc: method is nil but OutputPort.ReceiveMessage was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockReceiveMessage.Lock()
	mock.calls.ReceiveMessage = append(mock.calls.ReceiveMessage, callInfo)
	mock.lockReceiveMessage.Unlock()
	return mock.ReceiveMessageFunc(contextMoqParam)
}

// ReceiveMessageCalls gets all the calls that were made to ReceiveMessage.
// Check the length with:
//
//	len(mockedOutputPort.ReceiveMessageCalls())
func (mock *OutputPortMock) ReceiveMessageCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockReceiveMessage.RLock()
	calls = mock.calls.ReceiveMessage
	mock.lockReceiveMessage.RUnlock()
	return calls
}

// SendMessage calls SendMessageFunc.
func (mock *OutputPortMock) SendMessage(contextMoqParam context.Context, messageBody domain.MessageBody) domain.MessageStatus {
	if mock.SendMessageFunc == nil {
		panic("OutputPortMock.SendMessageFunc: method is nil but OutputPort.SendMessage was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		MessageBody     domain.MessageBody
	}{
		ContextMoqParam: contextMoqParam,
		MessageBody:     messageBody,
	}
	mock.lockSendMessage.Lock()
	mock.calls.SendMessage = append(mock.calls.SendMessage, callInfo)
	mock.lockSendMessage.Unlock()
	return mock.SendMessageFunc(contextMoqParam, messageBody)
}

// SendMessageCalls gets all the calls that were made to SendMessage.
// Check the length with:
//
//	len(mockedOutputPort.SendMessageCalls())
func (mock *OutputPortMock) SendMessageCalls() []struct {
	ContextMoqParam context.Context
	MessageBody     domain.MessageBody
} {
	var calls []struct {
		ContextMoqParam context.Context
		MessageBody     domain.MessageBody
	}
	mock.lockSendMessage.RLock()
	calls = mock.calls.SendMessage
	mock.lockSendMessage.RUnlock()
	return calls
}
